<template>
    <el-container>
        <!-- È°∂ÈÉ®ÊêúÁ¥¢Âå∫ -->
        <el-header style="padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
            <div style="max-width: 800px; margin: 0 auto;">
                <el-autocomplete
                    ref="searchInput"
                    v-model="searchQuery"
                    :fetch-suggestions="handleSearch"
                    placeholder="üîç ÊêúÁ¥¢‰π¶Á≠æÔºåÊåâÂõûËΩ¶Âø´ÈÄüË∑≥ËΩ¨ (Ctrl+K)"
                    prefix-icon="Search"
                    @select="handleSelect"
                    @keyup.enter="handleSearchJump"
                    @keydown="handleKeyDown"
                    clearable
                    size="large"
                    style="width: 100%;"
                    :popper-options="{
                        modifiers: [{
                            name: 'offset',
                            options: {
                                offset: [0, 8]
                            }
                        }]
                    }"
                    :popper-class="'search-suggestions'"
                >
                    <template #suffix>
                        <el-dropdown trigger="click" @command="handleSearchFilter">
                            <el-button :icon="Filter" circle size="small" style="margin-right: 8px;" />
                            <template #dropdown>
                                <el-dropdown-menu>
                                    <el-dropdown-item command="all">ÂÖ®ÈÉ®</el-dropdown-item>
                                    <el-dropdown-item divided command="recent">ÊúÄËøë‰ΩøÁî®</el-dropdown-item>
                                    <el-dropdown-item command="folder">ÊåâÊñá‰ª∂Â§πÁ≠õÈÄâ</el-dropdown-item>
                                </el-dropdown-menu>
                            </template>
                        </el-dropdown>
                    </template>
                    <template #default="{ item }">
                        <div style="display: flex; align-items: center; padding: 8px 0;">
                            <el-avatar 
                                v-if="!item.isHistory" 
                                :src="item.icon" 
                                size="small" 
                                style="margin-right: 12px; flex-shrink: 0;"
                            />
                            <el-icon v-else style="margin-right: 12px; color: #909399;">
                                <Clock />
                            </el-icon>
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-weight: 500; color: #303133; margin-bottom: 2px;">
                                    {{ item.title || item.value }}
                                </div>
                                <div v-if="item.url && !item.isHistory" style="font-size: 12px; color: #909399; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                    {{ item.url }}
                                </div>
                                <div v-if="item.isHistory" style="font-size: 12px; color: #909399;">
                                    ÊêúÁ¥¢ÂéÜÂè≤
                                </div>
                            </div>
                        </div>
                    </template>
                </el-autocomplete>
            </div>
        </el-header>

        <el-container>
            <!-- ‰æßËæπÊ†èÊñá‰ª∂Â§πÊ†ë -->
            <el-aside>
                <el-tree
                    v-model="currentFolder"
                    :data="folderTree"
                    :props="folderTreeProps"
                    node-key="id"
                    @node-click="handleFolderClick"
                />
            </el-aside>

            <!-- ‰∏ªÂÜÖÂÆπÂå∫ -->
            <el-main>
                <!-- Â∑•ÂÖ∑Ê†è -->
                <div>
                    <el-button type="primary" icon="Download" @click="importBookmarks">ÂØºÂÖ•‰π¶Á≠æ</el-button>
                    <el-button type="primary" icon="Upload" @click="exportBookmarks">ÂØºÂá∫‰π¶Á≠æ</el-button>
                    <el-button type="primary" icon="Plus" @click="addBookmark">Êñ∞Â¢û</el-button>
                    <el-button type="danger" icon="Delete" @click="clearBookmarks">Ê∏ÖÁ©∫</el-button>
                </div>

                <!-- ‰π¶Á≠æÂàóË°® -->
                <div>
                    <el-space wrap style="width: 1000px">
                        <el-card v-for="bookmark in bookmarks" :key="bookmark.id" style="width: 242px; height: 200px">
                            <template #header>
                                <el-text line-clamp="1">
                                    <el-avatar size="small" :src="bookmark.icon" />
                                    {{ bookmark.title }}
                                </el-text>
                            </template>
                            <el-link :href="bookmark.url" target="_blank">
                                <el-text line-clamp="1">
                                    {{ bookmark.url }}
                                </el-text>
                            </el-link>
                            <template #footer>
                                <el-button type="primary" :icon="Edit" circle @click="editBookmark(bookmark)" />
                                <el-button
                                    type="danger"
                                    :icon="Delete"
                                    circle
                                    @click="onRemoved(bookmark.id, bookmark)"
                                />
                            </template>
                        </el-card>
                    </el-space>
                </div>
            </el-main>
        </el-container>
        
        <!-- Ê∑ªÂä†‰π¶Á≠æ/Êñá‰ª∂Â§πÂØπËØùÊ°Ü -->
        <el-dialog 
            v-model="addBookmarkDialogVisible" 
            :title="bookmarkForm.url ? 'Ê∑ªÂä†‰π¶Á≠æ' : 'Ê∑ªÂä†Êñá‰ª∂Â§π'" 
            width="500px"
            :before-close="cancelAddBookmark"
        >
            <el-form :model="bookmarkForm" label-width="80px">
                <el-form-item label="Ê†áÈ¢ò" required>
                    <el-input 
                        v-model="bookmarkForm.title" 
                        placeholder="ËØ∑ËæìÂÖ•Ê†áÈ¢ò"
                        clearable
                    />
                </el-form-item>
                <el-form-item label="ÈìæÊé•">
                    <el-input 
                        v-model="bookmarkForm.url" 
                        placeholder="ËØ∑ËæìÂÖ•‰π¶Á≠æÈìæÊé•ÔºàÂ¶ÇÔºöhttps://example.comÔºâÔºå‰∏çÂ°´ÂàôÂàõÂª∫Êñá‰ª∂Â§π"
                        clearable
                    />
                </el-form-item>
                <el-form-item label="Êñá‰ª∂Â§π">
                    <el-tree-select
                        v-model="bookmarkForm.parentId"
                        :data="folderTree"
                        :props="folderTreeProps"
                        node-key="id"
                        :render-after-expand="false"
                        :check-strictly="true"
                        placeholder="ÈÄâÊã©Êñá‰ª∂Â§πÔºàÂèØÈÄâÔºâ"
                        clearable
                        style="width: 100%"
                    />
                </el-form-item>
            </el-form>
            
            <template #footer>
                <div class="dialog-footer">
                    <el-button @click="cancelAddBookmark">ÂèñÊ∂à</el-button>
                    <el-button type="primary" @click="confirmAddBookmark">Á°ÆÂÆö</el-button>
                </div>
            </template>
        </el-dialog>

        <!-- ÁºñËæë‰π¶Á≠æ/Êñá‰ª∂Â§πÂØπËØùÊ°Ü -->
        <el-dialog 
            v-model="editBookmarkDialogVisible" 
            :title="editForm.url ? 'ÁºñËæë‰π¶Á≠æ' : 'ÁºñËæëÊñá‰ª∂Â§π'" 
            width="500px"
            :before-close="cancelEdit"
        >
            <el-form :model="editForm" label-width="80px">
                <el-form-item label="Ê†áÈ¢ò" required>
                    <el-input 
                        v-model="editForm.title" 
                        placeholder="ËØ∑ËæìÂÖ•Ê†áÈ¢ò"
                        clearable
                    />
                </el-form-item>
                <el-form-item label="ÈìæÊé•" v-if="editForm.url !== undefined">
                    <el-input 
                        v-model="editForm.url" 
                        placeholder="ËØ∑ËæìÂÖ•‰π¶Á≠æÈìæÊé•ÔºàÂ¶ÇÔºöhttps://example.comÔºâ"
                        clearable
                    />
                </el-form-item>
                <el-form-item label="Êñá‰ª∂Â§π">
                    <el-tree-select
                        v-model="editForm.parentId"
                        :data="folderTree"
                        :props="folderTreeProps"
                        node-key="id"
                        :render-after-expand="false"
                        :check-strictly="true"
                        placeholder="ÈÄâÊã©Êñá‰ª∂Â§πÔºàÂèØÈÄâÔºâ"
                        clearable
                        style="width: 100%"
                    />
                </el-form-item>
            </el-form>
            
            <template #footer>
                <div class="dialog-footer">
                    <el-button @click="cancelEdit">ÂèñÊ∂à</el-button>
                    <el-button type="primary" @click="confirmEdit">Á°ÆÂÆö</el-button>
                </div>
            </template>
        </el-dialog>
    </el-container>
</template>

<script lang="ts" setup>
import { ref, onMounted, onUnmounted } from 'vue';
import { Link, Search, Download, Upload, Plus, Delete, Edit, Clock, Filter } from '@element-plus/icons-vue';
import { MyBookmarks } from './utils/bookmarks';
import { ElMessage } from 'element-plus';
import { parseHtmlToBookmarks, bookmarksToHtml } from './utils/parser';
import type { BookmarkTreeNode, CreateDetails } from './types/bookmark';

// ÊêúÁ¥¢Áõ∏ÂÖ≥
const searchQuery = ref('');
const allBookmarks = ref<BookmarkTreeNode[]>([]);
const searchHistory = ref<string[]>([]);
const maxSearchHistory = 10;
const searchInput = ref();
const searchFilter = ref('all'); // 'all', 'recent', 'folder'
const searchFolderId = ref('');

// ÊêúÁ¥¢Á≠õÈÄâÂô®Â§ÑÁêÜ
function handleSearchFilter(command: string) {
    searchFilter.value = command;
    if (command === 'folder') {
        // ÂèØ‰ª•Âú®ËøôÈáåÊ∑ªÂä†Êñá‰ª∂Â§πÈÄâÊã©ÈÄªËæë
        searchFolderId.value = currentFolder.value;
    } else {
        searchFolderId.value = '';
    }
    // ÈáçÊñ∞ÊêúÁ¥¢
    if (searchQuery.value.trim()) {
        handleSearch(searchQuery.value, () => {});
    }
}

// Âø´Êç∑ÈîÆÂ§ÑÁêÜ
function handleKeyDown(event: KeyboardEvent) {
    // ESC Ê∏ÖÁ©∫ÊêúÁ¥¢Ê°Ü
    if (event.key === 'Escape') {
        searchQuery.value = '';
        searchInput.value?.blur();
    }
}

// ÂÖ®Â±ÄÂø´Êç∑ÈîÆ
function handleGlobalKeyDown(event: KeyboardEvent) {
    // Ctrl+K Êàñ Cmd+K ËÅöÁÑ¶ÊêúÁ¥¢Ê°Ü
    if ((event.ctrlKey || event.metaKey) && event.key === 'k') {
        event.preventDefault();
        searchInput.value?.focus();
    }
    // / ËÅöÁÑ¶ÊêúÁ¥¢Ê°ÜÔºà‰ªÖÂΩì‰∏çÂú®ËæìÂÖ•Ê°ÜÂÜÖÊó∂Ôºâ
    else if (event.key === '/' && !isInInputElement(event.target as Element)) {
        event.preventDefault();
        searchInput.value?.focus();
    }
}

// Ê£ÄÊü•ÊòØÂê¶Âú®ËæìÂÖ•ÂÖÉÁ¥†ÂÜÖ
function isInInputElement(element: Element): boolean {
    const inputElements = ['INPUT', 'TEXTAREA', 'SELECT'];
    return inputElements.includes(element.tagName) || element.hasAttribute('contenteditable');
}

// Âä†ËΩΩÂÖ®ÈÉ®‰π¶Á≠æÔºàÁî®‰∫éÊêúÁ¥¢Ôºâ
async function loadAllBookmarks() {
    allBookmarks.value = await bookmarkDB.search('');
}

// Â§ÑÁêÜÊêúÁ¥¢Âª∫ËÆÆ
function handleSearch(query: string, callback: (data: any[]) => void) {
    if (query.trim()) {
        const queryLower = query.toLowerCase();
        let filteredBookmarks = allBookmarks.value;
        
        // ÊåâÁ≠õÈÄâÂô®ËøáÊª§
        switch (searchFilter.value) {
            case 'recent':
                filteredBookmarks = allBookmarks.value
                    .filter(bookmark => bookmark.dateLastUsed && bookmark.dateLastUsed > 0)
                    .sort((a, b) => (b.dateLastUsed || 0) - (a.dateLastUsed || 0))
                    .slice(0, 20);
                break;
            case 'folder':
                if (searchFolderId.value) {
                    filteredBookmarks = allBookmarks.value
                        .filter(bookmark => bookmark.parentId === searchFolderId.value);
                }
                break;
            default:
                filteredBookmarks = allBookmarks.value;
        }
        
        const results = filteredBookmarks
            .filter((bookmark) => 
                bookmark.title.toLowerCase().includes(queryLower) || 
                (bookmark.url && bookmark.url.toLowerCase().includes(queryLower))
            )
            .map((bookmark) => {
                // ËÆ°ÁÆóÂåπÈÖçÂ∫¶ÂàÜÊï∞
                let score = 0;
                const titleMatch = bookmark.title.toLowerCase().indexOf(queryLower);
                const urlMatch = bookmark.url ? bookmark.url.toLowerCase().indexOf(queryLower) : -1;
                
                // Ê†áÈ¢òÂåπÈÖçÂàÜÊï∞Êõ¥È´ò
                if (titleMatch === 0) score += 100; // ÂºÄÂ§¥ÂåπÈÖç
                else if (titleMatch > -1) score += 50; // ÈÉ®ÂàÜÂåπÈÖç
                
                if (urlMatch === 0) score += 30;
                else if (urlMatch > -1) score += 10;
                
                // ÊúÄËøë‰ΩøÁî®Âä†ÂàÜ
                if (bookmark.dateLastUsed && bookmark.dateLastUsed > 0) {
                    const daysSinceUse = (Date.now() / 1000 - bookmark.dateLastUsed) / (24 * 60 * 60);
                    score += Math.max(0, 20 - daysSinceUse);
                }
                
                return {
                    value: bookmark.title,
                    url: bookmark.url,
                    id: bookmark.id,
                    icon: bookmark.icon,
                    title: bookmark.title,
                    parentId: bookmark.parentId,
                    score
                };
            })
            .sort((a, b) => b.score - a.score) // ÊåâÂàÜÊï∞ÊéíÂ∫è
            .slice(0, 10); // ÈôêÂà∂Âª∫ËÆÆÊï∞Èáè
        
        // Â¶ÇÊûúÊ≤°ÊúâÂåπÈÖçÁªìÊûúÔºåÊòæÁ§∫ÊêúÁ¥¢ÂéÜÂè≤
        if (results.length === 0 && searchHistory.value.length > 0) {
            const historyResults = searchHistory.value
                .filter(item => item.toLowerCase().includes(queryLower))
                .slice(0, 5)
                .map(item => ({
                    value: item,
                    isHistory: true
                }));
            callback(historyResults);
        } else {
            callback(results);
        }
    } else {
        // ÊòæÁ§∫ÊúÄËøëÊêúÁ¥¢ÂéÜÂè≤
        const historyResults = searchHistory.value
            .slice(0, 5)
            .map(item => ({
                value: item,
                isHistory: true
            }));
        callback(historyResults);
    }
}

// Â§ÑÁêÜÈÄâ‰∏≠Âª∫ËÆÆÈ°π
function handleSelect(item: any) {
    if (item.isHistory) {
        // ÈÄâ‰∏≠ÂéÜÂè≤ÊêúÁ¥¢È°πÔºåËß¶ÂèëÊêúÁ¥¢
        searchQuery.value = item.value;
        handleSearchJump();
    } else if (item.url) {
        // Ê∑ªÂä†Âà∞ÊêúÁ¥¢ÂéÜÂè≤
        addToSearchHistory(searchQuery.value);
        window.open(item.url, '_blank');
        // Êõ¥Êñ∞‰ΩøÁî®Êó∂Èó¥
        updateBookmarkUsage(item.id);
    }
}

// Ê∑ªÂä†Âà∞ÊêúÁ¥¢ÂéÜÂè≤
function addToSearchHistory(query: string) {
    if (!query.trim()) return;
    
    const trimmedQuery = query.trim();
    // ÁßªÈô§Â∑≤Â≠òÂú®ÁöÑÈ°πÁõÆ
    const index = searchHistory.value.indexOf(trimmedQuery);
    if (index > -1) {
        searchHistory.value.splice(index, 1);
    }
    
    // Ê∑ªÂä†Âà∞ÂºÄÂ§¥
    searchHistory.value.unshift(trimmedQuery);
    
    // ‰øùÊåÅÂéÜÂè≤ËÆ∞ÂΩïÊï∞ÈáèÈôêÂà∂
    if (searchHistory.value.length > maxSearchHistory) {
        searchHistory.value = searchHistory.value.slice(0, maxSearchHistory);
    }
    
    // ‰øùÂ≠òÂà∞Êú¨Âú∞Â≠òÂÇ®
    localStorage.setItem('searchHistory', JSON.stringify(searchHistory.value));
}

// Êõ¥Êñ∞‰π¶Á≠æ‰ΩøÁî®ËÆ∞ÂΩï
async function updateBookmarkUsage(id: string) {
    try {
        await bookmarkDB.update(id, { 
            dateLastUsed: Date.now() / 1000 
        });
    } catch (error) {
        console.warn('Failed to update bookmark usage:', error);
    }
}

// Âä†ËΩΩÊêúÁ¥¢ÂéÜÂè≤
function loadSearchHistory() {
    try {
        const saved = localStorage.getItem('searchHistory');
        if (saved) {
            searchHistory.value = JSON.parse(saved);
        }
    } catch (error) {
        console.warn('Failed to load search history:', error);
        searchHistory.value = [];
    }
}

// Êñá‰ª∂Â§πÊ†ëÁõ∏ÂÖ≥
const folderTree = ref<any[]>([]);
const currentFolder = ref('');
const folderTreeProps = ref({
    value: 'id',
    label: 'title',
    children: 'children'
});

// ‰π¶Á≠æÂàóË°®Áõ∏ÂÖ≥
const bookmarks = ref<BookmarkTreeNode[]>([]);

// ‰π¶Á≠æÊï∞ÊçÆÂ∫ìÂÆû‰æã
const bookmarkDB = new MyBookmarks();

// Ê∑ªÂä†‰π¶Á≠æÂØπËØùÊ°ÜÁõ∏ÂÖ≥
const addBookmarkDialogVisible = ref(false);
const bookmarkForm = ref({
    title: '',
    url: '',
    parentId: ''
});

// ÁºñËæë‰π¶Á≠æÂØπËØùÊ°ÜÁõ∏ÂÖ≥
const editBookmarkDialogVisible = ref(false);
const editForm = ref({
    id: '',
    title: '',
    url: '',
    parentId: ''
});
const editingBookmark = ref<BookmarkTreeNode | null>(null);

// ÂàùÂßãÂåñ
onMounted(async () => {
    await loadFolderTree();
    await loadBookmarks();
    await loadAllBookmarks();
    loadSearchHistory();
    
    // Ê∑ªÂä†ÂÖ®Â±ÄÂø´Êç∑ÈîÆÁõëÂê¨
    document.addEventListener('keydown', handleGlobalKeyDown);
});

// Ê∏ÖÁêÜ
onUnmounted(() => {
    document.removeEventListener('keydown', handleGlobalKeyDown);
});

// Âä†ËΩΩÊñá‰ª∂Â§πÊ†ë
async function loadFolderTree() {
    // ‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩÊñá‰ª∂Â§πÊ†ë
    folderTree.value = await bookmarkDB.getFolderTree();
}

// Âä†ËΩΩ‰π¶Á≠æ
async function loadBookmarks() {
    // ÂÆûÈôÖÂ∫îÁî®‰∏≠ÔºåËøôÈáåÂ∫îËØ•Ê†πÊçÆÂΩìÂâçÈÄâ‰∏≠ÁöÑÊñá‰ª∂Â§πÂä†ËΩΩ‰π¶Á≠æ
    bookmarks.value = await bookmarkDB.getBookmarkChildren(currentFolder.value);
}

// ÊêúÁ¥¢Ë∑≥ËΩ¨
function handleSearchJump() {
    const query = searchQuery.value.trim();
    if (query) {
        // Ê∑ªÂä†Âà∞ÊêúÁ¥¢ÂéÜÂè≤
        addToSearchHistory(query);
        
        // ÊâæÂà∞Á¨¨‰∏Ä‰∏™ÂåπÈÖçÁöÑ‰π¶Á≠æÂπ∂Ë∑≥ËΩ¨
        const queryLower = query.toLowerCase();
        const matched = allBookmarks.value.find((bookmark) =>
            bookmark.title.toLowerCase().includes(queryLower) || 
            (bookmark.url && bookmark.url.toLowerCase().includes(queryLower))
        );
        
        if (matched && matched.url) {
            window.open(matched.url, '_blank');
            // Êõ¥Êñ∞‰ΩøÁî®ËÆ∞ÂΩï
            updateBookmarkUsage(matched.id);
        } else {
            ElMessage.info('Êú™ÊâæÂà∞ÂåπÈÖçÁöÑ‰π¶Á≠æ');
        }
    }
}

// Êñá‰ª∂Â§πÁÇπÂáª
function handleFolderClick(data: any) {
    currentFolder.value = data.id;
    loadBookmarks();
}

// ÂØºÂÖ•‰π¶Á≠æ
function importBookmarks() {
    console.log('ÂØºÂÖ•‰π¶Á≠æ');
    // ÂÆûÈôÖÂ∫îÁî®‰∏≠ÔºåËøôÈáåÂ∫îËØ•ÂÆûÁé∞ÂØºÂÖ•‰π¶Á≠æÁöÑÈÄªËæë
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.html';
    input.onchange = (e) => {
        const file = (e.target as HTMLInputElement).files?.[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const html = e.target?.result as string;
                const bookmarks = parseHtmlToBookmarks(html);
                console.log('ÂØºÂÖ•ÁöÑ‰π¶Á≠æ:', bookmarks);
                // ÂÆûÈôÖÂ∫îÁî®‰∏≠ÔºåËøôÈáåÂ∫îËØ•Â∞Ü‰π¶Á≠æ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
                onImportBegan();
                saveBookmarks(bookmarks).then(async () => {
                    onImportEnded();
                    // ÈáçÊñ∞Âä†ËΩΩÂÖ®ÈÉ®‰π¶Á≠æ‰ª•Êõ¥Êñ∞ÊêúÁ¥¢
                    await loadAllBookmarks();
                });
            };
            reader.readAsText(file);
        }
    };
    input.click();
}
async function saveBookmarks(bookmarks: BookmarkTreeNode[]) {
    for (const [index, bookmark] of bookmarks.entries()) {
        const node: CreateDetails = {
            title: bookmark.title,
            url: bookmark.url,
            index: index,
            type: bookmark.url ? 'bookmark' : 'folder',
            parentId: bookmark.parentId,
        };
        const result = await bookmarkDB.create(node);
        if (bookmark.children) {
            bookmark.children.forEach((b) => (b.parentId = result.id));
            await saveBookmarks(bookmark.children);
        }
    }
}

// ÂØºÂá∫‰π¶Á≠æ
async function exportBookmarks() {
    try {
        ElMessage.info('Ê≠£Âú®ÂØºÂá∫‰π¶Á≠æ...');
        
        // Ëé∑ÂèñÂÖ®ÈÉ®‰π¶Á≠æÊï∞ÊçÆ
        const allBookmarksData = await bookmarkDB.getTree();
        
        if (allBookmarksData.length === 0) {
            ElMessage.warning('Ê≤°ÊúâÂèØÂØºÂá∫ÁöÑ‰π¶Á≠æ');
            return;
        }
        
        // ÁîüÊàêÊñá‰ª∂ÂêçÔºàÂåÖÂê´Êó∂Èó¥Êà≥Ôºâ
        const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
        const filename = `mynav-bookmarks-${timestamp}.html`;
        
        // Â∞Ü‰π¶Á≠æÊï∞ÊçÆËΩ¨Êç¢‰∏∫HTML
        const htmlContent = bookmarksToHtml(allBookmarksData, 'MyNav ÂØºÂá∫ÁöÑ‰π¶Á≠æ');
        
        // ÂàõÂª∫‰∏ãËΩΩÈìæÊé•
        const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        
        // ÂàõÂª∫‰∏ãËΩΩÂÖÉÁ¥†Âπ∂Ëß¶Âèë‰∏ãËΩΩ
        const downloadLink = document.createElement('a');
        downloadLink.href = url;
        downloadLink.download = filename;
        downloadLink.style.display = 'none';
        
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        
        // Ê∏ÖÁêÜURLÂØπË±°
        URL.revokeObjectURL(url);
        
        ElMessage.success(`‰π¶Á≠æÂ∑≤ÊàêÂäüÂØºÂá∫‰∏∫ ${filename}`);
        
        console.log('ÂØºÂá∫‰π¶Á≠æÊàêÂäü:', {
            count: countBookmarks(allBookmarksData),
            filename,
            size: `${Math.round(blob.size / 1024)}KB`
        });
        
    } catch (error) {
        console.error('ÂØºÂá∫‰π¶Á≠æÂ§±Ë¥•:', error);
        ElMessage.error('ÂØºÂá∫‰π¶Á≠æÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
    }
}

// ËÆ°ÁÆó‰π¶Á≠æÊï∞ÈáèÔºàÈÄíÂΩíÁªüËÆ°Ôºâ
function countBookmarks(bookmarks: BookmarkTreeNode[]): number {
    let count = 0;
    for (const bookmark of bookmarks) {
        if (bookmark.type === 'bookmark') {
            count++;
        } else if (bookmark.children) {
            count += countBookmarks(bookmark.children);
        }
    }
    return count;
}

// Ê∑ªÂä†‰π¶Á≠æ
function addBookmark() {
    // ÈáçÁΩÆË°®ÂçïÊï∞ÊçÆ
    bookmarkForm.value = {
        title: '',
        url: '',
        parentId: currentFolder.value || ''
    };
    // ÊòæÁ§∫ÂØπËØùÊ°Ü
    addBookmarkDialogVisible.value = true;
}

// Á°ÆËÆ§Ê∑ªÂä†‰π¶Á≠æÊàñÊñá‰ª∂Â§π
async function confirmAddBookmark() {
    if (!bookmarkForm.value.title.trim()) {
        ElMessage.warning('ËØ∑ËæìÂÖ•Ê†áÈ¢ò');
        return;
    }
    
    const hasUrl = bookmarkForm.value.url.trim();
    
    // Â¶ÇÊûúÊúâURLÔºåÈ™åËØÅURLÊ†ºÂºè
    if (hasUrl) {
        try {
            new URL(bookmarkForm.value.url);
        } catch (error) {
            ElMessage.error('ËØ∑ËæìÂÖ•Ê≠£Á°ÆÁöÑURLÊ†ºÂºèÔºà‰ª•http://Êàñhttps://ÂºÄÂ§¥Ôºâ');
            return;
        }
    }

    try {
        const createDetails: CreateDetails = {
            title: bookmarkForm.value.title.trim(),
            url: hasUrl ? bookmarkForm.value.url.trim() : undefined,
            parentId: bookmarkForm.value.parentId || currentFolder.value,
            type: hasUrl ? 'bookmark' : 'folder',
            index: bookmarks.value.length
        };
        
        const newItem = await bookmarkDB.create(createDetails);
        
        const itemType = hasUrl ? '‰π¶Á≠æ' : 'Êñá‰ª∂Â§π';
        ElMessage.success(`${itemType}Ê∑ªÂä†ÊàêÂäü`);
        
        // ÂÖ≥Èó≠ÂØπËØùÊ°Ü
        addBookmarkDialogVisible.value = false;
        
        // ÈáçÊñ∞Âä†ËΩΩ‰π¶Á≠æÂàóË°®ÂíåÊñá‰ª∂Â§πÊ†ë
        await loadBookmarks();
        await loadFolderTree();
        
        console.log(`Êñ∞Â¢û${itemType}:`, newItem);
    } catch (error) {
        ElMessage.error('Ê∑ªÂä†Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
        console.error('Ê∑ªÂä†ÈîôËØØ:', error);
    }
}

// ÂèñÊ∂àÊ∑ªÂä†‰π¶Á≠æ
function cancelAddBookmark() {
    addBookmarkDialogVisible.value = false;
    bookmarkForm.value = {
        title: '',
        url: '',
        parentId: ''
    };
}

// Ê∏ÖÁ©∫‰π¶Á≠æ
function clearBookmarks() {
    bookmarkDB.clear();
    loadBookmarks();
    loadFolderTree();
    loadAllBookmarks(); // ÈáçÊñ∞Âä†ËΩΩÂÖ®ÈÉ®‰π¶Á≠æ‰ª•Êõ¥Êñ∞ÊêúÁ¥¢
    console.log('Ê∏ÖÁ©∫‰π¶Á≠æ');

    ElMessage.success('‰π¶Á≠æÂ∑≤Ê∏ÖÁ©∫');
}

// Êñ∞Â¢ûÁöÑÂáΩÊï∞
function onChanged(id: string, changeInfo: any) {
    console.log('Bookmark changed:', id, changeInfo);
    // Â§ÑÁêÜ‰π¶Á≠æÊõ¥ÊîπÈÄªËæë
    loadBookmarks();
    loadFolderTree();
    loadAllBookmarks(); // ÈáçÊñ∞Âä†ËΩΩÂÖ®ÈÉ®‰π¶Á≠æ‰ª•Êõ¥Êñ∞ÊêúÁ¥¢
}

function onChildrenReordered(id: string, reorderInfo: object) {
    console.log('Children reordered for:', id, reorderInfo);
    // Â§ÑÁêÜÂ≠êÈ°πÈáçÊéíÈÄªËæë
    loadBookmarks();
}

function onCreated(id: string, bookmark: BookmarkTreeNode) {
    console.log('Bookmark created:', id, bookmark);
    // Â§ÑÁêÜÂàõÂª∫ÈÄªËæë
    loadBookmarks();
    loadFolderTree();
    loadAllBookmarks(); // ÈáçÊñ∞Âä†ËΩΩÂÖ®ÈÉ®‰π¶Á≠æ‰ª•Êõ¥Êñ∞ÊêúÁ¥¢
}

function onImportBegan() {
    console.log('Import began');
    // Â§ÑÁêÜÂØºÂÖ•ÂºÄÂßãÈÄªËæë
    ElMessage.info('ÂºÄÂßãÂØºÂÖ•‰π¶Á≠æ...');
}

function onImportEnded() {
    ElMessage.success(`ÊàêÂäüÂØºÂÖ•‰π¶Á≠æ`);
    loadBookmarks();
    loadFolderTree();
    loadAllBookmarks(); // ÈáçÊñ∞Âä†ËΩΩÂÖ®ÈÉ®‰π¶Á≠æ‰ª•Êõ¥Êñ∞ÊêúÁ¥¢
}

function onMoved(id: string, moveInfo: object) {
    console.log('Bookmark moved:', moveInfo);
    // Â§ÑÁêÜÁßªÂä®ÈÄªËæë
    loadBookmarks();
    loadFolderTree();
    loadAllBookmarks(); // ÈáçÊñ∞Âä†ËΩΩÂÖ®ÈÉ®‰π¶Á≠æ‰ª•Êõ¥Êñ∞ÊêúÁ¥¢
}

async function onRemoved(id: string, removeInfo: object) {
    await bookmarkDB.remove(id);
    console.log('Bookmark removed:', removeInfo);
    // Â§ÑÁêÜÂà†Èô§ÈÄªËæë
    loadBookmarks();
    loadFolderTree();
    loadAllBookmarks(); // ÈáçÊñ∞Âä†ËΩΩÂÖ®ÈÉ®‰π¶Á≠æ‰ª•Êõ¥Êñ∞ÊêúÁ¥¢
}

// ÁºñËæë‰π¶Á≠æ
function editBookmark(bookmark: BookmarkTreeNode) {
    editingBookmark.value = bookmark;
    editForm.value = {
        id: bookmark.id,
        title: bookmark.title,
        url: bookmark.url || '',
        parentId: bookmark.parentId || ''
    };
    editBookmarkDialogVisible.value = true;
}

// Á°ÆËÆ§ÁºñËæë
async function confirmEdit() {
    if (!editForm.value.title.trim()) {
        ElMessage.warning('ËØ∑ËæìÂÖ•Ê†áÈ¢ò');
        return;
    }
    
    const hasUrl = editForm.value.url.trim();
    
    // Â¶ÇÊûúÊúâURLÔºåÈ™åËØÅURLÊ†ºÂºè
    if (hasUrl) {
        try {
            new URL(editForm.value.url);
        } catch (error) {
            ElMessage.error('ËØ∑ËæìÂÖ•Ê≠£Á°ÆÁöÑURLÊ†ºÂºèÔºà‰ª•http://Êàñhttps://ÂºÄÂ§¥Ôºâ');
            return;
        }
    }

    try {
        const changes: any = {
            title: editForm.value.title.trim(),
            parentId: editForm.value.parentId || null
        };
        
        // Âè™Êúâ‰π¶Á≠æÊâçÊõ¥Êñ∞URL
        if (editingBookmark.value?.url !== undefined) {
            changes.url = hasUrl ? editForm.value.url.trim() : undefined;
            if (changes.url) {
                changes.icon = bookmarkDB.getGoogleFaviconUrl(changes.url);
            }
        }
        
        await bookmarkDB.update(editForm.value.id, changes);
        
        const itemType = editingBookmark.value?.url ? '‰π¶Á≠æ' : 'Êñá‰ª∂Â§π';
        ElMessage.success(`${itemType}ÁºñËæëÊàêÂäü`);
        
        // ÂÖ≥Èó≠ÂØπËØùÊ°Ü
        editBookmarkDialogVisible.value = false;
        
        // ÈáçÊñ∞Âä†ËΩΩ‰π¶Á≠æÂàóË°®ÂíåÊñá‰ª∂Â§πÊ†ë
        await loadBookmarks();
        await loadFolderTree();
        // ÈáçÊñ∞Âä†ËΩΩÂÖ®ÈÉ®‰π¶Á≠æ‰ª•Êõ¥Êñ∞ÊêúÁ¥¢
        await loadAllBookmarks();
        
        console.log(`ÁºñËæë${itemType}:`, changes);
    } catch (error) {
        ElMessage.error('ÁºñËæëÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
        console.error('ÁºñËæëÈîôËØØ:', error);
    }
}

// ÂèñÊ∂àÁºñËæë
function cancelEdit() {
    editBookmarkDialogVisible.value = false;
    editForm.value = {
        id: '',
        title: '',
        url: '',
        parentId: ''
    };
    editingBookmark.value = null;
}
</script>

<style scoped>
/* ÊêúÁ¥¢Ê°ÜÊ†∑Âºè */
.el-header {
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
}

/* ÊîπËøõÊêúÁ¥¢Ê°ÜËæìÂÖ•Ê†∑Âºè */
:deep(.el-input__wrapper) {
    border-radius: 25px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    border: 2px solid rgba(255, 255, 255, 0.2);
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
}

:deep(.el-input__wrapper:hover) {
    border-color: rgba(255, 255, 255, 0.4);
}

:deep(.el-input__wrapper.is-focus) {
    border-color: #409EFF;
    box-shadow: 0 4px 12px rgba(64, 158, 255, 0.3);
}

:deep(.el-input__inner) {
    font-size: 16px;
    color: #303133;
}

:deep(.el-input__inner::placeholder) {
    color: #909399;
}

/* Â∑•ÂÖ∑Ê†èÊ†∑Âºè */
.el-main > div:first-child {
    margin-bottom: 20px;
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
}

/* ‰π¶Á≠æÂç°ÁâáÊ†∑Âºè‰ºòÂåñ */
.el-card {
    transition: all 0.3s ease;
    border-radius: 12px;
    overflow: hidden;
}

.el-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
}

/* ‰æßËæπÊ†èÊ†∑Âºè */
.el-aside {
    background: #f8f9fa;
    border-right: 1px solid #e4e7ed;
    padding: 20px;
}

/* ÂìçÂ∫îÂºèËÆæËÆ° */
@media (max-width: 768px) {
    .el-header {
        padding: 15px;
    }
    
    .el-header > div {
        max-width: 100%;
    }
    
    .el-space {
        width: 100% !important;
    }
    
    .el-card {
        width: 100% !important;
        max-width: 300px;
    }
}
</style>

<style>
/* ÂÖ®Â±ÄÊ†∑ÂºèÔºà‰∏çÂèó scoped ÈôêÂà∂Ôºâ*/
.search-suggestions {
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border: none;
    margin-top: 4px;
}

.search-suggestions .el-autocomplete-suggestion__list {
    padding: 8px;
}

.search-suggestions .el-autocomplete-suggestion__list li {
    border-radius: 8px;
    margin: 2px 0;
    padding: 8px 12px;
    transition: all 0.2s ease;
}

.search-suggestions .el-autocomplete-suggestion__list li:hover {
    background: #f0f9ff;
    transform: translateX(4px);
}

.search-suggestions .el-autocomplete-suggestion__list li.highlighted {
    background: #e6f7ff;
    border-color: #409EFF;
}
</style>
